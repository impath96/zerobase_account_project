# 프로젝트 시작 전 알아야할 개념

## 트랜잭션 개념

`ACID`

- `Atomic(원자성)`
  - All or Nothing, 모든 작업이 실행되거나 모두 실행되지 않아야 한다.
  - 예시) A 계좌에서 B 계좌로 잔액을 송금할 때
    - `A 계좌 잔액 줄이기` 작업과 `B 계좌 잔액 늘리기` 작업은 함께 성공하거나 함께 실패해야 한다.
- `Consistency(일관성)`
  - 모든 트랜잭션이 종료된 후에는 DB의 제약조건을 모두 지키고 있는 상태가 되어야 한다.
  - 예시) 잔액이 0원 이상이다.
    - 이를 위반하는 트랜잭션은 모두 중단된다.
- `Isolation(격리성)`
  - 트랜잭션은 다른 트랜잭션과 독립적으로 동작해야 한다.
  - A 트랜잭션이 하는 일은 B 트랜잭션은 모르게 해야한다.
  - 하지만 현실은...
    - 성능과 안전성의 트레이드 오프 관계에 있는 부분이다.
    - READ_UNCOMMITTED > READ_COMMITTED > REPEATABLE_READ > SERIALIZABLE 순서로 성능은 떨어지고 격리성(고립성)은 증가
      - 격리성이 낮을 때 일어나는 문제 : Dirty read, Phantom read 등이 발생 가능
    - 일반적으로 MySQL InnoDB의 기본 값은 REPEATABLE_READ 를 많이 활용
- `Durability(지속성)`
  - commit을 하게 되면 지속(저장)이 꼭 된다.
  - DB 저장이 실패하더라도 모든 로그를 모두 남겨서 DB에 순차적으로 모두 반영이 되도록 한다.

---

## Embedded Redis 실행

### Redis 사용 목적
- SpinLock을 활용한 동시성 제어
- 동시성 제어를 AOP를 활용하여 실습하는데 활용되는 인프라
- DB의존성이 높은 Lock을 사용할 경우 성능이 떨어질 수 있다(낙관 락, 비관 락)
  - 원하는 방식으로 Lock을 제어할 수 있도록 사용

### LocalRedis 실행 설정
- Spring Boot가 기동하면서 Bean을 등록할 때 redis를 실행하고, 종료되면서 Bean을 삭제할 때 redis를 종료하도록 설정
- `주의점` : 해당 Bean이 redis repository보다 빨리 뜰 수 있도록 패키지 순서를 위쪽으로 해야 한다.

---

## 중복거래 방지(AOP)

`동시성 이슈(concurrency issue)이란?`
- 여러 요청이 동일한 자원에 접근해 발생하는 문제들을 총칭한다.
- 주로, DB에서 동일한 레코드를 `동시 접근`할 때 문제가 발생한다.

주로 문제가 되는 시나리오 

### 해결 방법

1. DB 의존적인 방법(DB Isolation 활용, JPA LOCK 활용)
2. 기타 인프라를 활용하는 방법
   - redis(싱글 스레드, 메모리 저장 방식 -> 성능이 좋다.)
3. 비즈니스 로직으로 해결하는 방법


## 리팩토링

리팩토링 : 내부 동작은 `변경하지 않으면서` 내부 구조를 개선하는 방법

### 리팩토링 하는 목적

1. 가독성 향상
2. 유지보수 향상
   - 중복 코드 제거
   - 복잡한 구조의 개선
3. 기타
   - 안티패턴(나쁜 냄새) 제거
   - 개발 능력의 향상 및 역량의 향상

결국 `생산성 향상`과 `개인 역량의 향상`


